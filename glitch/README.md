# Халява для студентов по 1 заданию, GitHub

---

# Задача 1

1.  Перекидываем резервную копию базы на сервер:

    ```bash
    scp dump.fasta.gz mc:/students/glitch/
    ```

2.  Разделение dump.fasta.gz по файлам:

    _Учитывая небольшой размер архива, мы можем использовать только оперативную память для работы с базой и сэкономить место на диске, не распаковывая её. Так же команда split позволяет проводить операции над конечными файлами на месте, что дополнительно позволяет сэкономить место на диске при использовании gzip_

    ```bash
    # Смотрим на формат базы, это oneline FASTA, на каждую последовательность выделено 2 строки
    zcat dump.fasta.gz | head

    # Разделяем на отдельные файлы
    zcat dump.fasta.gz | split \
        -l 2 \                   # Разделяем по две строки (т.к. oneline-FASTA)
        -a 3 \                   # Расширяем нумерацию до трех символов
        --numeric-suffixes=1 \   # Используем 10-ную систему счисления со стартом = 1
        --additional-suffix=.fa \ # Добавляем суффикс .fa
        --filter='gzip > $FILE.gz' \ # Сжимаем итоговый файл
        - \                      # Берем данные из стандартного ввода
        sequence_                # Префикс файлов

    # Или короче:
    zcat dump.fasta.gz | split -l 2 -a 3 --numeric-suffixes=1 --filter='gzip > $FILE.fa.gz' - sequence_

    # Проверяем результат
    zgrep -c '>' dump.fasta.gz  # Считаем количество последовательностей (133 записи)
    ls seq*                     # Проверяем файлы
    zcat sequence_133.fa.gz     # Проверяем целостность конечного файла

    # Удаляем исходную базу
    rm dump.fasta.gz
    ```

3.  Перед разделением файлов по папкам, посмотрим какая информация указана в заголовках, создадим необходимые директории:

    ```bash
    zgrep '>' seq*  # Смотрим заголовки
    mkdir -p Task1/fastafiles/{mRNA,protein,reference}
    ```

    _В результате видим, что заголовки включают в себя три типа ключевых слов: full genome, complete sequence, chromosome, mRNA и protein. При этом есть заголовки к mRNA, включающие protein как подстроку - это стоит учесть при перемещении_

4.  Разделяем файлы:

    ```bash
    # Перемещаем mRNA файлы (проверяем с echo сначала)
    zgrep -li '^>.*mrna' seq* | xargs -I {} echo mv {} Task1/fastafiles/mRNA/
    zgrep -li '^>.*mrna' seq* | xargs -I {} mv {} Task1/fastafiles/mRNA/

    # Перемещаем protein файлы
    zgrep -li '^>.*protein' seq* | xargs -I {} echo mv {} Task1/fastafiles/protein/
    zgrep -li '^>.*protein' seq* | xargs -I {} mv {} Task1/fastafiles/protein/

    # Перемещаем геномы
    zgrep -li '^>.*\(genome\|sequence\|chromosome\)' seq* | xargs -I {} echo mv {} Task1/fastafiles/reference/
    zgrep -li '^>.*\(genome\|sequence\|chromosome\)' seq* | xargs -I {} mv {} Task1/fastafiles/reference/

    # Переименовываем последовательности геномов в формат 'род_вид.fa.gz'
    cd Task1/fastafiles/reference
    for file in *fa.gz; do
        header=$(zcat "$file" | head -n 1)
        family=$(echo "$header" | cut -d' ' -f2 | tr '[:upper:]' '[:lower:]')
        genus=$(echo "$header" | cut -d' ' -f3 | tr '[:upper:]' '[:lower:]')
        mv "$file" "${family}_${genus}.fa.gz"
    done
    ```

5.  Сохраняем историю и перекидываем обратно на компьютер:

    ```bash
    # На сервере
    history > history.log

    # На целевом компьютере
    scp mc:/students/glitch/history.log .

    # Как бы выглядела команда, если бы нужно было скачать все файлы из папки, заканчивающиеся на .txt?
    scp 'mc:/students/glitch/*.txt' .
    ```

---

# Задача 2

## Какой процесс самый тяжелый?
Для начала необходимо посмотреть на процессы в системе:
```bash
top -o RES # сортировка по занимаемой оперативе
```

![alt text](https://i.postimg.cc/y88fHQfC/image.png)

Мы видим, что самым затратным процессом в системе является **java**:
* **Владелец**: root
* **PID**: 254603
* **RES**: 2.7gb
* **CPU**: 4%

По пути исполняемого файла можно увидеть, что это сервер Minecraft.
```bash
ps -p 254603 -o cmd= # показываем команду и пути
# или
pwdx 254603 # только пути
```

Завершить процесс мы можем несколькими способами:
```bash
# Отправка сигнала TERM (аккуратное завершение процесса)
sudo kill 254603
pkill -TERM java # если знаем только имя процесса
pgrep java # можно так же найти PID по имени

# Запасной вариант: отправка сигнала KILL (принудительно завершение процесса)
sudo kill -9 254603
pkill -TERM java

# Проверка завершения -- должен быть пустой вывод
ps aux | grep java
```

## Объяснение колонок в таблице процессов top
| Колонка  | Расшифровка                                                                     |
| -------- | ------------------------------------------------------------------------------- |
| **PID**    | Идентификатор процесса                                      |
| **USER**    | Владелец процесса                                      |
| **PR**   | Итоговый приоритет процесса, который учитывает планировщик ядра (чем меньше значение, тем выше приоритет, меняется непосредственно ядром)                   |
| **NI**   | "Niceness" — "любезность" процесса, с его помощью ядро рассчитывает приоритет процесса (от -20 до 19, управляется пользователем)             |
| **VIRT** | Виртуальная память (всё адресное пространство, включая своп, библиотеки, mmap). |
| **RES**  | Реальная физическая память, занимаемая процессом в ОЗУ.                         |
| **SHR**  | Разделяемая память (shared libraries, общие сегменты).                          |
| **S**    | Состояние процесса (R, S, D, T, Z и т.д.).                                      |

## Изменение единиц измерения памяти

* Нажать **E** — изменяется отображение памяти в строке суммарной статистики.

* Нажать **e** — изменяется отображение памяти в списке процессов.

Доступные единицы:
- **KiB** (кибибайты) = 1024 bytes (по-умолчанию)
- **MiB** (мебибайты) = 1024² bytes  
- **GiB** (гибибайты) = 1024³ bytes
- **TiB** (тебибайты) = 1024⁴ bytes
- **PiB** (пебибайты) = 1024⁵ bytes

## Swap

**Swap** — это область в **ROM**, используемая как расширение оперативной памяти.
Когда RAM исчерпана, редко используемые данные выгружаются в swap.

Минус - намного **медленнее RAM**

## Состояние процессов

| Состояние | Обозначение           | Описание                                                                         |
| --------- | --------------------- | -------------------------------------------------------------------------------- |
| **R**     | Running               | Процесс выполняется прямо сейчас.                                                |
| **S**     | Sleeping              | Ожидание события (например, данных от диска/сети).                               |
| **D**     | Uninterruptible Sleep | "Жёсткий сон", обычно ожидание ввода-вывода, не прерывается сигналами.           |
| **T**     | Stopped               | Остановлен (сигналом или отладчиком). Не тратит ресурсы                                            |
| **Z**     | Zombie                | Завершён, но не убран из таблицы процессов (нет родителя или он занят, чтобы он мог послать сигнал о завершении). Не тратит ресурсы |

---

# Комментарий по гитхабу:
В идеале у вас должно было быть два коммита "Выполнена задача 1" и "Выполнена задача 2" множество осмысленных коммитов решения подзадач, типа "Разбил файлы по директориям"/"Выполнил подзадачу ... из задачи 1". 

**Коммиты должны быть осмысленными и отражать, что именно за изменения они несут**. Большинство закончило за упокой с неинформативными коммитами а-ля "Update README.md", "Последние изменения". Кст, оформлять по-русски не лучшая затея. На будущее, особенно для репозиториев хакатонов, статей и т.п., вы делаете комментарии для международной аудитории, если репозиторий открытый, поэтому **пишите на англе**. 

В большинстве случаев, думаю, это результат того, что вносились изменения к тем задачам, которые уже "помечены" выполненными предыдущими коммитами. Тут важный тейк, перед отправлением коммитов в удаленный репозиторий вы можете делать с ними всё, что угодно. Желательно приводить к наиболее читаемой и осмысленной форме. Вот пара полезных команд для этого:

## Изменить последний коммит

```bash
git commit --amend -m "Обновленный комментарий"
```

## Если забыли добавить файлы в последний коммит

```bash
git add <файл>
git commit --amend --no-edit # тут комментарий не меняется
```

## Отменить изменения в файле (вернуть к последнему коммиту, даже если удален)

```bash
git restore file.txt
# Аналогично можно
git checkout HEAD -- file.txt # Необязательно HEAD!!!
```

## Убрать файл из staging (отмена `git add`)

```bash
git restore --staged file.txt
```

## Откат изменений с помощью reset

`git reset` позволяет «откатить» коммиты и управлять состоянием файлов в staging (индекс) и рабочей директории.

Основные режимы:

1. `git reset --soft <коммит>`

   • Перемещает указатель HEAD к выбранному коммиту
   • Все изменения из отменённых коммитов остаются в staging (готовы к новому коммиту)
   • Используется, если нужно поправить сообщение или пересобрать коммит

   Пример:
   
   ```bash
   git reset --soft HEAD~1 
   # убирает последний коммит, но файлы остаются добавленными
   ```

2. `git reset --mixed <коммит>   (режим по умолчанию)`

   • HEAD перемещается к выбранному коммиту
   • Изменения из отменённых коммитов остаются в рабочей директории
   • Индекс очищается (файлы больше не подготовлены к коммиту)

   Пример:
   ```bash
   git reset --mixed HEAD~2 
   # убирает два последних коммита, оставляет изменения, но их надо заново добавлять с помощью add
   ```

3. `git reset --hard <коммит>`

   • Полный откат: HEAD перемещается к коммиту, индекс и рабочая директория приводятся к его состоянию
   • Все изменения теряются безвозвратно
   • Использовать с осторожностью!

   Пример:
   ```bash
   git reset --hard HEAD~1
   # удаляет последний коммит и все изменения из него
   ```

Итого:
- --soft   = откат коммитов, изменения остаются staged
- --mixed  = откат коммитов, изменения остаются только в файлах
- --hard   = полный откат и удаление изменений

Совет: перед reset делайте git log, чтобы убедиться, к какому коммиту хотите вернуться.

